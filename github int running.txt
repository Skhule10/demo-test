import datetime
from importlib.resources import contents
import requests
import pyhdb
from typing import Dict, Any, Optional, List
from fastapi import HTTPException, status
import os
import requests
import pyhdb
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, List
from hdbcli import dbapi
import aiohttp
import asyncio
import os
from fastapi import HTTPException
from requests.auth import HTTPBasicAuth
import logging
## hardcoded credentials as of now 

import os
import uuid
import aiohttp
from datetime import datetime
from typing import Dict, Any
from fastapi import HTTPException
import requests

class GitHubIntegration:
    def __init__(self):
        self.token = os.getenv("GITHUB_TOKEN")  # GitHub token
        self.repo_owner = os.getenv("GITHUB_REPO_OWNER")
        self.repo_name = os.getenv("GITHUB_REPO_NAME")
        self.maas_url = os.getenv("MAAS_API_URL")  # MAAS API URL
        self.headers = {
            "Authorization": f"token {self.token}",
            "Accept": "application/vnd.github.v3+json"
        }
    def get_access_token():
        try:
            token_url = os.getenv ("TOKEN_URL")
            client_id = os.getenv ("CLIENT_ID")
            client_secret = os.getenv ("CLIENT_SECRET_MAAS")
            auth = HTTPBasicAuth(client_id, client_secret)
            payload = {
                'grant_type': 'client_credentials'
            }
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
            response = requests.post(token_url, auth=auth, data=payload, headers=headers)
            response_data = response.json()
            return response_data['access_token']
        except Exception as e:
            logging.error(f"Error getting access token: {str(e)}")
            return None

    async def fetch_repo_structure(self, session, path="") -> Dict[str, Any]:
        url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}/contents/{path}"
        print("Final GitHub API URL:", url)

        async with session.get(url, headers=self.headers) as response:
            if response.status != 200:
                text = await response.text()
                raise Exception(f"Failed to fetch contents for {path}: {text}")
            return await response.json()

    async def build_tree(self, session, path="") -> Dict[str, Any]:
        contents = await self.fetch_repo_structure(session, path)
        tree = {
            "id": str(uuid.uuid4()),
            "name": path.split("/")[-1] if path else self.repo_name,
            "type": "folder",
            "children": []
        }

        for item in contents:
            if item["type"] == "dir":
                folder = await self.build_tree(session, item["path"])
                tree["children"].append(folder)
            elif item["type"] == "file":
                tree["children"].append({
                    "id": str(uuid.uuid4()),
                    "name": item["name"],
                    "type": "file",
                    "path": item["path"],
                    "size": item.get("size", 0)
                })

        return tree
    
    async def call_table(self):
        """
        Calls FastAPI endpoint with the user input
        """
        try:
            access_token = self.get_access_token()
            if not access_token:
                logging.error("Failed to get access token")
                return None

            api_url = self.maas_url + "FILES/"
            headers = {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": f"Bearer {access_token}"
            }

            async with aiohttp.ClientSession() as session:
                try:
                    async with session.get(api_url, headers=headers) as response:
                        if response.status == 200:
                            data = await response.json()
                            
                        else:
                            logging.error(f"API call Table failed with status {response.status}")
                            return None
                except Exception as e:
                    logging.error(f"Error in table API call: {str(e)}")
                    return None
        except Exception as e:
            logging.error(f"Error in call_table: {str(e)}")
            return None
    
    async def sync_repo_to_maas(self, dry_run=False) -> Dict[str, Any]:
        try:
            async with aiohttp.ClientSession() as session:
                # Building the repository structure as a tree
                tree = await self.build_tree(session)
                print("Repository structure tree:", tree)
                # If it's a dry run, just return the structure without posting it
                if dry_run:
                    return {
                        "status": "success",
                        "message": "Dry run completed.",
                        "tree": tree
                    }
                call_table = await self.call_table()
                print("Call table response:", call_table)
                # Sending the repository structure to the MAAS API
                async with session.post(self.maas_url, json=tree) as maas_response:
                    if maas_response.status != 200:
                        error = await maas_response.text()
                        raise Exception(f"Failed to post to MAAS: {error}")

                    return {
                        "status": "success",
                        "message": "GitHub repo structure uploaded to MAAS container."
                    }
        except Exception as e:
            return {"status": "error", "message": str(e)}

